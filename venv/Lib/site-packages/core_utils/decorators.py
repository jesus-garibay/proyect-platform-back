import warnings

from aws_lambda_powertools import Logger
from typing import Any, Dict, Callable
from functools import wraps, partial

__all__ = [
    "lambda_interceptor",
    "ignore_warnings"
]


def lambda_interceptor(function: Callable[[Dict, Any], Any] = None,
                       logger: Logger = None):
    if not logger:
        raise AttributeError('logger is required')
    if function is None:
        return partial(lambda_interceptor, logger=logger)

    @wraps(function)
    def decorator(event, context):
        try:
            logger.info({'Event': event})
        except Exception as e:
            logger.debug(str(e))
            # logger.info(__parse_event_for_logging(event))
        try:
            response = function(event, context)
        except Exception as e:
            logger.error(e)
            raise e
        logger.info({'lambda response': response})
        return response

    return decorator


def ignore_warnings(test_func):
    """
    Decorator
    use:
        @ignore_warnings
        def test_lambda_handler(self):
            "your logic"
            pass

    Ignore warnings generated by connections not explicitly closed
    """

    def do_test(self, *args, **kwargs):
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", ResourceWarning)
            test_func(self, *args, **kwargs)

    return do_test
